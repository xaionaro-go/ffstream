// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.12
// source: ffstream.proto

package ffstream_grpc

import (
	context "context"
	avpipeline "github.com/xaionaro-go/avpipeline/protobuf/avpipeline"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	FFStream_SetLoggingLevel_FullMethodName          = "/ffstream_grpc.FFStream/SetLoggingLevel"
	FFStream_RemoveOutput_FullMethodName             = "/ffstream_grpc.FFStream/RemoveOutput"
	FFStream_GetCurrentOutput_FullMethodName         = "/ffstream_grpc.FFStream/GetCurrentOutput"
	FFStream_SwitchOutputByProps_FullMethodName      = "/ffstream_grpc.FFStream/SwitchOutputByProps"
	FFStream_GetStats_FullMethodName                 = "/ffstream_grpc.FFStream/GetStats"
	FFStream_GetOutputSRTStats_FullMethodName        = "/ffstream_grpc.FFStream/GetOutputSRTStats"
	FFStream_GetSRTFlagInt_FullMethodName            = "/ffstream_grpc.FFStream/GetSRTFlagInt"
	FFStream_SetSRTFlagInt_FullMethodName            = "/ffstream_grpc.FFStream/SetSRTFlagInt"
	FFStream_WaitChan_FullMethodName                 = "/ffstream_grpc.FFStream/WaitChan"
	FFStream_End_FullMethodName                      = "/ffstream_grpc.FFStream/End"
	FFStream_GetPipelines_FullMethodName             = "/ffstream_grpc.FFStream/GetPipelines"
	FFStream_GetAutoBitRateCalculator_FullMethodName = "/ffstream_grpc.FFStream/GetAutoBitRateCalculator"
	FFStream_SetAutoBitRateCalculator_FullMethodName = "/ffstream_grpc.FFStream/SetAutoBitRateCalculator"
	FFStream_GetFPSFraction_FullMethodName           = "/ffstream_grpc.FFStream/GetFPSFraction"
	FFStream_SetFPSFraction_FullMethodName           = "/ffstream_grpc.FFStream/SetFPSFraction"
	FFStream_GetBitRates_FullMethodName              = "/ffstream_grpc.FFStream/GetBitRates"
	FFStream_GetLatencies_FullMethodName             = "/ffstream_grpc.FFStream/GetLatencies"
	FFStream_GetInputQuality_FullMethodName          = "/ffstream_grpc.FFStream/GetInputQuality"
	FFStream_GetOutputQuality_FullMethodName         = "/ffstream_grpc.FFStream/GetOutputQuality"
	FFStream_Monitor_FullMethodName                  = "/ffstream_grpc.FFStream/Monitor"
)

// FFStreamClient is the client API for FFStream service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FFStreamClient interface {
	SetLoggingLevel(ctx context.Context, in *SetLoggingLevelRequest, opts ...grpc.CallOption) (*SetLoggingLevelReply, error)
	RemoveOutput(ctx context.Context, in *RemoveOutputRequest, opts ...grpc.CallOption) (*RemoveOutputReply, error)
	GetCurrentOutput(ctx context.Context, in *GetCurrentOutputRequest, opts ...grpc.CallOption) (*GetCurrentOutputReply, error)
	SwitchOutputByProps(ctx context.Context, in *SwitchOutputByPropsRequest, opts ...grpc.CallOption) (*SwitchOutputByPropsReply, error)
	GetStats(ctx context.Context, in *GetStatsRequest, opts ...grpc.CallOption) (*GetStatsReply, error)
	GetOutputSRTStats(ctx context.Context, in *GetOutputSRTStatsRequest, opts ...grpc.CallOption) (*GetOutputSRTStatsReply, error)
	GetSRTFlagInt(ctx context.Context, in *GetSRTFlagIntRequest, opts ...grpc.CallOption) (*GetSRTFlagIntReply, error)
	SetSRTFlagInt(ctx context.Context, in *SetSRTFlagIntRequest, opts ...grpc.CallOption) (*SetSRTFlagIntReply, error)
	WaitChan(ctx context.Context, in *WaitRequest, opts ...grpc.CallOption) (FFStream_WaitChanClient, error)
	End(ctx context.Context, in *EndRequest, opts ...grpc.CallOption) (*EndReply, error)
	GetPipelines(ctx context.Context, in *GetPipelinesRequest, opts ...grpc.CallOption) (*GetPipelinesResponse, error)
	GetAutoBitRateCalculator(ctx context.Context, in *GetAutoBitRateCalculatorRequest, opts ...grpc.CallOption) (*GetAutoBitRateCalculatorReply, error)
	SetAutoBitRateCalculator(ctx context.Context, in *SetAutoBitRateCalculatorRequest, opts ...grpc.CallOption) (*SetAutoBitRateCalculatorReply, error)
	GetFPSFraction(ctx context.Context, in *GetFPSFractionRequest, opts ...grpc.CallOption) (*GetFPSFractionReply, error)
	SetFPSFraction(ctx context.Context, in *SetFPSFractionRequest, opts ...grpc.CallOption) (*SetFPSFractionReply, error)
	GetBitRates(ctx context.Context, in *GetBitRatesRequest, opts ...grpc.CallOption) (*GetBitRatesReply, error)
	GetLatencies(ctx context.Context, in *GetLatenciesRequest, opts ...grpc.CallOption) (*GetLatenciesReply, error)
	GetInputQuality(ctx context.Context, in *GetInputQualityRequest, opts ...grpc.CallOption) (*GetInputQualityReply, error)
	GetOutputQuality(ctx context.Context, in *GetOutputQualityRequest, opts ...grpc.CallOption) (*GetOutputQualityReply, error)
	Monitor(ctx context.Context, in *avpipeline.MonitorRequest, opts ...grpc.CallOption) (FFStream_MonitorClient, error)
}

type fFStreamClient struct {
	cc grpc.ClientConnInterface
}

func NewFFStreamClient(cc grpc.ClientConnInterface) FFStreamClient {
	return &fFStreamClient{cc}
}

func (c *fFStreamClient) SetLoggingLevel(ctx context.Context, in *SetLoggingLevelRequest, opts ...grpc.CallOption) (*SetLoggingLevelReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetLoggingLevelReply)
	err := c.cc.Invoke(ctx, FFStream_SetLoggingLevel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) RemoveOutput(ctx context.Context, in *RemoveOutputRequest, opts ...grpc.CallOption) (*RemoveOutputReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveOutputReply)
	err := c.cc.Invoke(ctx, FFStream_RemoveOutput_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) GetCurrentOutput(ctx context.Context, in *GetCurrentOutputRequest, opts ...grpc.CallOption) (*GetCurrentOutputReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCurrentOutputReply)
	err := c.cc.Invoke(ctx, FFStream_GetCurrentOutput_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) SwitchOutputByProps(ctx context.Context, in *SwitchOutputByPropsRequest, opts ...grpc.CallOption) (*SwitchOutputByPropsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwitchOutputByPropsReply)
	err := c.cc.Invoke(ctx, FFStream_SwitchOutputByProps_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) GetStats(ctx context.Context, in *GetStatsRequest, opts ...grpc.CallOption) (*GetStatsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStatsReply)
	err := c.cc.Invoke(ctx, FFStream_GetStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) GetOutputSRTStats(ctx context.Context, in *GetOutputSRTStatsRequest, opts ...grpc.CallOption) (*GetOutputSRTStatsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetOutputSRTStatsReply)
	err := c.cc.Invoke(ctx, FFStream_GetOutputSRTStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) GetSRTFlagInt(ctx context.Context, in *GetSRTFlagIntRequest, opts ...grpc.CallOption) (*GetSRTFlagIntReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSRTFlagIntReply)
	err := c.cc.Invoke(ctx, FFStream_GetSRTFlagInt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) SetSRTFlagInt(ctx context.Context, in *SetSRTFlagIntRequest, opts ...grpc.CallOption) (*SetSRTFlagIntReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetSRTFlagIntReply)
	err := c.cc.Invoke(ctx, FFStream_SetSRTFlagInt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) WaitChan(ctx context.Context, in *WaitRequest, opts ...grpc.CallOption) (FFStream_WaitChanClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &FFStream_ServiceDesc.Streams[0], FFStream_WaitChan_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &fFStreamWaitChanClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FFStream_WaitChanClient interface {
	Recv() (*WaitReply, error)
	grpc.ClientStream
}

type fFStreamWaitChanClient struct {
	grpc.ClientStream
}

func (x *fFStreamWaitChanClient) Recv() (*WaitReply, error) {
	m := new(WaitReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fFStreamClient) End(ctx context.Context, in *EndRequest, opts ...grpc.CallOption) (*EndReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EndReply)
	err := c.cc.Invoke(ctx, FFStream_End_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) GetPipelines(ctx context.Context, in *GetPipelinesRequest, opts ...grpc.CallOption) (*GetPipelinesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPipelinesResponse)
	err := c.cc.Invoke(ctx, FFStream_GetPipelines_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) GetAutoBitRateCalculator(ctx context.Context, in *GetAutoBitRateCalculatorRequest, opts ...grpc.CallOption) (*GetAutoBitRateCalculatorReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAutoBitRateCalculatorReply)
	err := c.cc.Invoke(ctx, FFStream_GetAutoBitRateCalculator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) SetAutoBitRateCalculator(ctx context.Context, in *SetAutoBitRateCalculatorRequest, opts ...grpc.CallOption) (*SetAutoBitRateCalculatorReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetAutoBitRateCalculatorReply)
	err := c.cc.Invoke(ctx, FFStream_SetAutoBitRateCalculator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) GetFPSFraction(ctx context.Context, in *GetFPSFractionRequest, opts ...grpc.CallOption) (*GetFPSFractionReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFPSFractionReply)
	err := c.cc.Invoke(ctx, FFStream_GetFPSFraction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) SetFPSFraction(ctx context.Context, in *SetFPSFractionRequest, opts ...grpc.CallOption) (*SetFPSFractionReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetFPSFractionReply)
	err := c.cc.Invoke(ctx, FFStream_SetFPSFraction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) GetBitRates(ctx context.Context, in *GetBitRatesRequest, opts ...grpc.CallOption) (*GetBitRatesReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBitRatesReply)
	err := c.cc.Invoke(ctx, FFStream_GetBitRates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) GetLatencies(ctx context.Context, in *GetLatenciesRequest, opts ...grpc.CallOption) (*GetLatenciesReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLatenciesReply)
	err := c.cc.Invoke(ctx, FFStream_GetLatencies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) GetInputQuality(ctx context.Context, in *GetInputQualityRequest, opts ...grpc.CallOption) (*GetInputQualityReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetInputQualityReply)
	err := c.cc.Invoke(ctx, FFStream_GetInputQuality_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) GetOutputQuality(ctx context.Context, in *GetOutputQualityRequest, opts ...grpc.CallOption) (*GetOutputQualityReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetOutputQualityReply)
	err := c.cc.Invoke(ctx, FFStream_GetOutputQuality_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) Monitor(ctx context.Context, in *avpipeline.MonitorRequest, opts ...grpc.CallOption) (FFStream_MonitorClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &FFStream_ServiceDesc.Streams[1], FFStream_Monitor_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &fFStreamMonitorClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FFStream_MonitorClient interface {
	Recv() (*avpipeline.MonitorEvent, error)
	grpc.ClientStream
}

type fFStreamMonitorClient struct {
	grpc.ClientStream
}

func (x *fFStreamMonitorClient) Recv() (*avpipeline.MonitorEvent, error) {
	m := new(avpipeline.MonitorEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// FFStreamServer is the server API for FFStream service.
// All implementations must embed UnimplementedFFStreamServer
// for forward compatibility
type FFStreamServer interface {
	SetLoggingLevel(context.Context, *SetLoggingLevelRequest) (*SetLoggingLevelReply, error)
	RemoveOutput(context.Context, *RemoveOutputRequest) (*RemoveOutputReply, error)
	GetCurrentOutput(context.Context, *GetCurrentOutputRequest) (*GetCurrentOutputReply, error)
	SwitchOutputByProps(context.Context, *SwitchOutputByPropsRequest) (*SwitchOutputByPropsReply, error)
	GetStats(context.Context, *GetStatsRequest) (*GetStatsReply, error)
	GetOutputSRTStats(context.Context, *GetOutputSRTStatsRequest) (*GetOutputSRTStatsReply, error)
	GetSRTFlagInt(context.Context, *GetSRTFlagIntRequest) (*GetSRTFlagIntReply, error)
	SetSRTFlagInt(context.Context, *SetSRTFlagIntRequest) (*SetSRTFlagIntReply, error)
	WaitChan(*WaitRequest, FFStream_WaitChanServer) error
	End(context.Context, *EndRequest) (*EndReply, error)
	GetPipelines(context.Context, *GetPipelinesRequest) (*GetPipelinesResponse, error)
	GetAutoBitRateCalculator(context.Context, *GetAutoBitRateCalculatorRequest) (*GetAutoBitRateCalculatorReply, error)
	SetAutoBitRateCalculator(context.Context, *SetAutoBitRateCalculatorRequest) (*SetAutoBitRateCalculatorReply, error)
	GetFPSFraction(context.Context, *GetFPSFractionRequest) (*GetFPSFractionReply, error)
	SetFPSFraction(context.Context, *SetFPSFractionRequest) (*SetFPSFractionReply, error)
	GetBitRates(context.Context, *GetBitRatesRequest) (*GetBitRatesReply, error)
	GetLatencies(context.Context, *GetLatenciesRequest) (*GetLatenciesReply, error)
	GetInputQuality(context.Context, *GetInputQualityRequest) (*GetInputQualityReply, error)
	GetOutputQuality(context.Context, *GetOutputQualityRequest) (*GetOutputQualityReply, error)
	Monitor(*avpipeline.MonitorRequest, FFStream_MonitorServer) error
	mustEmbedUnimplementedFFStreamServer()
}

// UnimplementedFFStreamServer must be embedded to have forward compatible implementations.
type UnimplementedFFStreamServer struct {
}

func (UnimplementedFFStreamServer) SetLoggingLevel(context.Context, *SetLoggingLevelRequest) (*SetLoggingLevelReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLoggingLevel not implemented")
}
func (UnimplementedFFStreamServer) RemoveOutput(context.Context, *RemoveOutputRequest) (*RemoveOutputReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveOutput not implemented")
}
func (UnimplementedFFStreamServer) GetCurrentOutput(context.Context, *GetCurrentOutputRequest) (*GetCurrentOutputReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentOutput not implemented")
}
func (UnimplementedFFStreamServer) SwitchOutputByProps(context.Context, *SwitchOutputByPropsRequest) (*SwitchOutputByPropsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwitchOutputByProps not implemented")
}
func (UnimplementedFFStreamServer) GetStats(context.Context, *GetStatsRequest) (*GetStatsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStats not implemented")
}
func (UnimplementedFFStreamServer) GetOutputSRTStats(context.Context, *GetOutputSRTStatsRequest) (*GetOutputSRTStatsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOutputSRTStats not implemented")
}
func (UnimplementedFFStreamServer) GetSRTFlagInt(context.Context, *GetSRTFlagIntRequest) (*GetSRTFlagIntReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSRTFlagInt not implemented")
}
func (UnimplementedFFStreamServer) SetSRTFlagInt(context.Context, *SetSRTFlagIntRequest) (*SetSRTFlagIntReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSRTFlagInt not implemented")
}
func (UnimplementedFFStreamServer) WaitChan(*WaitRequest, FFStream_WaitChanServer) error {
	return status.Errorf(codes.Unimplemented, "method WaitChan not implemented")
}
func (UnimplementedFFStreamServer) End(context.Context, *EndRequest) (*EndReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method End not implemented")
}
func (UnimplementedFFStreamServer) GetPipelines(context.Context, *GetPipelinesRequest) (*GetPipelinesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPipelines not implemented")
}
func (UnimplementedFFStreamServer) GetAutoBitRateCalculator(context.Context, *GetAutoBitRateCalculatorRequest) (*GetAutoBitRateCalculatorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAutoBitRateCalculator not implemented")
}
func (UnimplementedFFStreamServer) SetAutoBitRateCalculator(context.Context, *SetAutoBitRateCalculatorRequest) (*SetAutoBitRateCalculatorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAutoBitRateCalculator not implemented")
}
func (UnimplementedFFStreamServer) GetFPSFraction(context.Context, *GetFPSFractionRequest) (*GetFPSFractionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFPSFraction not implemented")
}
func (UnimplementedFFStreamServer) SetFPSFraction(context.Context, *SetFPSFractionRequest) (*SetFPSFractionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetFPSFraction not implemented")
}
func (UnimplementedFFStreamServer) GetBitRates(context.Context, *GetBitRatesRequest) (*GetBitRatesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBitRates not implemented")
}
func (UnimplementedFFStreamServer) GetLatencies(context.Context, *GetLatenciesRequest) (*GetLatenciesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLatencies not implemented")
}
func (UnimplementedFFStreamServer) GetInputQuality(context.Context, *GetInputQualityRequest) (*GetInputQualityReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInputQuality not implemented")
}
func (UnimplementedFFStreamServer) GetOutputQuality(context.Context, *GetOutputQualityRequest) (*GetOutputQualityReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOutputQuality not implemented")
}
func (UnimplementedFFStreamServer) Monitor(*avpipeline.MonitorRequest, FFStream_MonitorServer) error {
	return status.Errorf(codes.Unimplemented, "method Monitor not implemented")
}
func (UnimplementedFFStreamServer) mustEmbedUnimplementedFFStreamServer() {}

// UnsafeFFStreamServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FFStreamServer will
// result in compilation errors.
type UnsafeFFStreamServer interface {
	mustEmbedUnimplementedFFStreamServer()
}

func RegisterFFStreamServer(s grpc.ServiceRegistrar, srv FFStreamServer) {
	s.RegisterService(&FFStream_ServiceDesc, srv)
}

func _FFStream_SetLoggingLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLoggingLevelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).SetLoggingLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FFStream_SetLoggingLevel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).SetLoggingLevel(ctx, req.(*SetLoggingLevelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_RemoveOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveOutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).RemoveOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FFStream_RemoveOutput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).RemoveOutput(ctx, req.(*RemoveOutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_GetCurrentOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrentOutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).GetCurrentOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FFStream_GetCurrentOutput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).GetCurrentOutput(ctx, req.(*GetCurrentOutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_SwitchOutputByProps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchOutputByPropsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).SwitchOutputByProps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FFStream_SwitchOutputByProps_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).SwitchOutputByProps(ctx, req.(*SwitchOutputByPropsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_GetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).GetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FFStream_GetStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).GetStats(ctx, req.(*GetStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_GetOutputSRTStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOutputSRTStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).GetOutputSRTStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FFStream_GetOutputSRTStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).GetOutputSRTStats(ctx, req.(*GetOutputSRTStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_GetSRTFlagInt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSRTFlagIntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).GetSRTFlagInt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FFStream_GetSRTFlagInt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).GetSRTFlagInt(ctx, req.(*GetSRTFlagIntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_SetSRTFlagInt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSRTFlagIntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).SetSRTFlagInt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FFStream_SetSRTFlagInt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).SetSRTFlagInt(ctx, req.(*SetSRTFlagIntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_WaitChan_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WaitRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FFStreamServer).WaitChan(m, &fFStreamWaitChanServer{ServerStream: stream})
}

type FFStream_WaitChanServer interface {
	Send(*WaitReply) error
	grpc.ServerStream
}

type fFStreamWaitChanServer struct {
	grpc.ServerStream
}

func (x *fFStreamWaitChanServer) Send(m *WaitReply) error {
	return x.ServerStream.SendMsg(m)
}

func _FFStream_End_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).End(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FFStream_End_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).End(ctx, req.(*EndRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_GetPipelines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPipelinesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).GetPipelines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FFStream_GetPipelines_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).GetPipelines(ctx, req.(*GetPipelinesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_GetAutoBitRateCalculator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAutoBitRateCalculatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).GetAutoBitRateCalculator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FFStream_GetAutoBitRateCalculator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).GetAutoBitRateCalculator(ctx, req.(*GetAutoBitRateCalculatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_SetAutoBitRateCalculator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAutoBitRateCalculatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).SetAutoBitRateCalculator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FFStream_SetAutoBitRateCalculator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).SetAutoBitRateCalculator(ctx, req.(*SetAutoBitRateCalculatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_GetFPSFraction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFPSFractionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).GetFPSFraction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FFStream_GetFPSFraction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).GetFPSFraction(ctx, req.(*GetFPSFractionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_SetFPSFraction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetFPSFractionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).SetFPSFraction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FFStream_SetFPSFraction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).SetFPSFraction(ctx, req.(*SetFPSFractionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_GetBitRates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBitRatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).GetBitRates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FFStream_GetBitRates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).GetBitRates(ctx, req.(*GetBitRatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_GetLatencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatenciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).GetLatencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FFStream_GetLatencies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).GetLatencies(ctx, req.(*GetLatenciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_GetInputQuality_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInputQualityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).GetInputQuality(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FFStream_GetInputQuality_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).GetInputQuality(ctx, req.(*GetInputQualityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_GetOutputQuality_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOutputQualityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).GetOutputQuality(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FFStream_GetOutputQuality_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).GetOutputQuality(ctx, req.(*GetOutputQualityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_Monitor_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(avpipeline.MonitorRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FFStreamServer).Monitor(m, &fFStreamMonitorServer{ServerStream: stream})
}

type FFStream_MonitorServer interface {
	Send(*avpipeline.MonitorEvent) error
	grpc.ServerStream
}

type fFStreamMonitorServer struct {
	grpc.ServerStream
}

func (x *fFStreamMonitorServer) Send(m *avpipeline.MonitorEvent) error {
	return x.ServerStream.SendMsg(m)
}

// FFStream_ServiceDesc is the grpc.ServiceDesc for FFStream service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FFStream_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ffstream_grpc.FFStream",
	HandlerType: (*FFStreamServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetLoggingLevel",
			Handler:    _FFStream_SetLoggingLevel_Handler,
		},
		{
			MethodName: "RemoveOutput",
			Handler:    _FFStream_RemoveOutput_Handler,
		},
		{
			MethodName: "GetCurrentOutput",
			Handler:    _FFStream_GetCurrentOutput_Handler,
		},
		{
			MethodName: "SwitchOutputByProps",
			Handler:    _FFStream_SwitchOutputByProps_Handler,
		},
		{
			MethodName: "GetStats",
			Handler:    _FFStream_GetStats_Handler,
		},
		{
			MethodName: "GetOutputSRTStats",
			Handler:    _FFStream_GetOutputSRTStats_Handler,
		},
		{
			MethodName: "GetSRTFlagInt",
			Handler:    _FFStream_GetSRTFlagInt_Handler,
		},
		{
			MethodName: "SetSRTFlagInt",
			Handler:    _FFStream_SetSRTFlagInt_Handler,
		},
		{
			MethodName: "End",
			Handler:    _FFStream_End_Handler,
		},
		{
			MethodName: "GetPipelines",
			Handler:    _FFStream_GetPipelines_Handler,
		},
		{
			MethodName: "GetAutoBitRateCalculator",
			Handler:    _FFStream_GetAutoBitRateCalculator_Handler,
		},
		{
			MethodName: "SetAutoBitRateCalculator",
			Handler:    _FFStream_SetAutoBitRateCalculator_Handler,
		},
		{
			MethodName: "GetFPSFraction",
			Handler:    _FFStream_GetFPSFraction_Handler,
		},
		{
			MethodName: "SetFPSFraction",
			Handler:    _FFStream_SetFPSFraction_Handler,
		},
		{
			MethodName: "GetBitRates",
			Handler:    _FFStream_GetBitRates_Handler,
		},
		{
			MethodName: "GetLatencies",
			Handler:    _FFStream_GetLatencies_Handler,
		},
		{
			MethodName: "GetInputQuality",
			Handler:    _FFStream_GetInputQuality_Handler,
		},
		{
			MethodName: "GetOutputQuality",
			Handler:    _FFStream_GetOutputQuality_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WaitChan",
			Handler:       _FFStream_WaitChan_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Monitor",
			Handler:       _FFStream_Monitor_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ffstream.proto",
}
