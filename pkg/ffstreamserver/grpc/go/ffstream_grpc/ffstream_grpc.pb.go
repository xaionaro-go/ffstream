// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package ffstream_grpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// FFStreamClient is the client API for FFStream service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FFStreamClient interface {
	SetLoggingLevel(ctx context.Context, in *SetLoggingLevelRequest, opts ...grpc.CallOption) (*SetLoggingLevelReply, error)
	AddInput(ctx context.Context, in *AddInputRequest, opts ...grpc.CallOption) (*AddInputReply, error)
	AddOutput(ctx context.Context, in *AddOutputRequest, opts ...grpc.CallOption) (*AddOutputReply, error)
	RemoveOutput(ctx context.Context, in *RemoveOutputRequest, opts ...grpc.CallOption) (*RemoveOutputReply, error)
	GetRecoderConfig(ctx context.Context, in *GetRecoderConfigRequest, opts ...grpc.CallOption) (*GetRecoderConfigReply, error)
	SetRecoderConfig(ctx context.Context, in *SetRecoderConfigRequest, opts ...grpc.CallOption) (*SetRecoderConfigReply, error)
	GetTolerableOutputQueueSizeBytes(ctx context.Context, in *GetTolerableOutputQueueSizeBytesRequest, opts ...grpc.CallOption) (*GetTolerableOutputQueueSizeBytesReply, error)
	SetTolerableOutputQueueSizeBytes(ctx context.Context, in *SetTolerableOutputQueueSizeBytesRequest, opts ...grpc.CallOption) (*SetTolerableOutputQueueSizeBytesReply, error)
	Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartReply, error)
	GetStats(ctx context.Context, in *GetStatsRequest, opts ...grpc.CallOption) (*GetStatsReply, error)
	GetOutputSRTStats(ctx context.Context, in *GetOutputSRTStatsRequest, opts ...grpc.CallOption) (*GetOutputSRTStatsReply, error)
	GetSRTFlagInt(ctx context.Context, in *GetSRTFlagIntRequest, opts ...grpc.CallOption) (*GetSRTFlagIntReply, error)
	SetSRTFlagInt(ctx context.Context, in *SetSRTFlagIntRequest, opts ...grpc.CallOption) (*SetSRTFlagIntReply, error)
	WaitChan(ctx context.Context, in *WaitRequest, opts ...grpc.CallOption) (FFStream_WaitChanClient, error)
	End(ctx context.Context, in *EndRequest, opts ...grpc.CallOption) (*EndReply, error)
}

type fFStreamClient struct {
	cc grpc.ClientConnInterface
}

func NewFFStreamClient(cc grpc.ClientConnInterface) FFStreamClient {
	return &fFStreamClient{cc}
}

func (c *fFStreamClient) SetLoggingLevel(ctx context.Context, in *SetLoggingLevelRequest, opts ...grpc.CallOption) (*SetLoggingLevelReply, error) {
	out := new(SetLoggingLevelReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/SetLoggingLevel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) AddInput(ctx context.Context, in *AddInputRequest, opts ...grpc.CallOption) (*AddInputReply, error) {
	out := new(AddInputReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/AddInput", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) AddOutput(ctx context.Context, in *AddOutputRequest, opts ...grpc.CallOption) (*AddOutputReply, error) {
	out := new(AddOutputReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/AddOutput", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) RemoveOutput(ctx context.Context, in *RemoveOutputRequest, opts ...grpc.CallOption) (*RemoveOutputReply, error) {
	out := new(RemoveOutputReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/RemoveOutput", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) GetRecoderConfig(ctx context.Context, in *GetRecoderConfigRequest, opts ...grpc.CallOption) (*GetRecoderConfigReply, error) {
	out := new(GetRecoderConfigReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/GetRecoderConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) SetRecoderConfig(ctx context.Context, in *SetRecoderConfigRequest, opts ...grpc.CallOption) (*SetRecoderConfigReply, error) {
	out := new(SetRecoderConfigReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/SetRecoderConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) GetTolerableOutputQueueSizeBytes(ctx context.Context, in *GetTolerableOutputQueueSizeBytesRequest, opts ...grpc.CallOption) (*GetTolerableOutputQueueSizeBytesReply, error) {
	out := new(GetTolerableOutputQueueSizeBytesReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/GetTolerableOutputQueueSizeBytes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) SetTolerableOutputQueueSizeBytes(ctx context.Context, in *SetTolerableOutputQueueSizeBytesRequest, opts ...grpc.CallOption) (*SetTolerableOutputQueueSizeBytesReply, error) {
	out := new(SetTolerableOutputQueueSizeBytesReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/SetTolerableOutputQueueSizeBytes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartReply, error) {
	out := new(StartReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) GetStats(ctx context.Context, in *GetStatsRequest, opts ...grpc.CallOption) (*GetStatsReply, error) {
	out := new(GetStatsReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/GetStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) GetOutputSRTStats(ctx context.Context, in *GetOutputSRTStatsRequest, opts ...grpc.CallOption) (*GetOutputSRTStatsReply, error) {
	out := new(GetOutputSRTStatsReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/GetOutputSRTStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) GetSRTFlagInt(ctx context.Context, in *GetSRTFlagIntRequest, opts ...grpc.CallOption) (*GetSRTFlagIntReply, error) {
	out := new(GetSRTFlagIntReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/GetSRTFlagInt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) SetSRTFlagInt(ctx context.Context, in *SetSRTFlagIntRequest, opts ...grpc.CallOption) (*SetSRTFlagIntReply, error) {
	out := new(SetSRTFlagIntReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/SetSRTFlagInt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fFStreamClient) WaitChan(ctx context.Context, in *WaitRequest, opts ...grpc.CallOption) (FFStream_WaitChanClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FFStream_serviceDesc.Streams[0], "/ffstream_grpc.FFStream/WaitChan", opts...)
	if err != nil {
		return nil, err
	}
	x := &fFStreamWaitChanClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FFStream_WaitChanClient interface {
	Recv() (*WaitReply, error)
	grpc.ClientStream
}

type fFStreamWaitChanClient struct {
	grpc.ClientStream
}

func (x *fFStreamWaitChanClient) Recv() (*WaitReply, error) {
	m := new(WaitReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fFStreamClient) End(ctx context.Context, in *EndRequest, opts ...grpc.CallOption) (*EndReply, error) {
	out := new(EndReply)
	err := c.cc.Invoke(ctx, "/ffstream_grpc.FFStream/End", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FFStreamServer is the server API for FFStream service.
// All implementations must embed UnimplementedFFStreamServer
// for forward compatibility
type FFStreamServer interface {
	SetLoggingLevel(context.Context, *SetLoggingLevelRequest) (*SetLoggingLevelReply, error)
	AddInput(context.Context, *AddInputRequest) (*AddInputReply, error)
	AddOutput(context.Context, *AddOutputRequest) (*AddOutputReply, error)
	RemoveOutput(context.Context, *RemoveOutputRequest) (*RemoveOutputReply, error)
	GetRecoderConfig(context.Context, *GetRecoderConfigRequest) (*GetRecoderConfigReply, error)
	SetRecoderConfig(context.Context, *SetRecoderConfigRequest) (*SetRecoderConfigReply, error)
	GetTolerableOutputQueueSizeBytes(context.Context, *GetTolerableOutputQueueSizeBytesRequest) (*GetTolerableOutputQueueSizeBytesReply, error)
	SetTolerableOutputQueueSizeBytes(context.Context, *SetTolerableOutputQueueSizeBytesRequest) (*SetTolerableOutputQueueSizeBytesReply, error)
	Start(context.Context, *StartRequest) (*StartReply, error)
	GetStats(context.Context, *GetStatsRequest) (*GetStatsReply, error)
	GetOutputSRTStats(context.Context, *GetOutputSRTStatsRequest) (*GetOutputSRTStatsReply, error)
	GetSRTFlagInt(context.Context, *GetSRTFlagIntRequest) (*GetSRTFlagIntReply, error)
	SetSRTFlagInt(context.Context, *SetSRTFlagIntRequest) (*SetSRTFlagIntReply, error)
	WaitChan(*WaitRequest, FFStream_WaitChanServer) error
	End(context.Context, *EndRequest) (*EndReply, error)
	mustEmbedUnimplementedFFStreamServer()
}

// UnimplementedFFStreamServer must be embedded to have forward compatible implementations.
type UnimplementedFFStreamServer struct {
}

func (UnimplementedFFStreamServer) SetLoggingLevel(context.Context, *SetLoggingLevelRequest) (*SetLoggingLevelReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLoggingLevel not implemented")
}
func (UnimplementedFFStreamServer) AddInput(context.Context, *AddInputRequest) (*AddInputReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddInput not implemented")
}
func (UnimplementedFFStreamServer) AddOutput(context.Context, *AddOutputRequest) (*AddOutputReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddOutput not implemented")
}
func (UnimplementedFFStreamServer) RemoveOutput(context.Context, *RemoveOutputRequest) (*RemoveOutputReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveOutput not implemented")
}
func (UnimplementedFFStreamServer) GetRecoderConfig(context.Context, *GetRecoderConfigRequest) (*GetRecoderConfigReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRecoderConfig not implemented")
}
func (UnimplementedFFStreamServer) SetRecoderConfig(context.Context, *SetRecoderConfigRequest) (*SetRecoderConfigReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetRecoderConfig not implemented")
}
func (UnimplementedFFStreamServer) GetTolerableOutputQueueSizeBytes(context.Context, *GetTolerableOutputQueueSizeBytesRequest) (*GetTolerableOutputQueueSizeBytesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTolerableOutputQueueSizeBytes not implemented")
}
func (UnimplementedFFStreamServer) SetTolerableOutputQueueSizeBytes(context.Context, *SetTolerableOutputQueueSizeBytesRequest) (*SetTolerableOutputQueueSizeBytesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTolerableOutputQueueSizeBytes not implemented")
}
func (UnimplementedFFStreamServer) Start(context.Context, *StartRequest) (*StartReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
}
func (UnimplementedFFStreamServer) GetStats(context.Context, *GetStatsRequest) (*GetStatsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStats not implemented")
}
func (UnimplementedFFStreamServer) GetOutputSRTStats(context.Context, *GetOutputSRTStatsRequest) (*GetOutputSRTStatsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOutputSRTStats not implemented")
}
func (UnimplementedFFStreamServer) GetSRTFlagInt(context.Context, *GetSRTFlagIntRequest) (*GetSRTFlagIntReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSRTFlagInt not implemented")
}
func (UnimplementedFFStreamServer) SetSRTFlagInt(context.Context, *SetSRTFlagIntRequest) (*SetSRTFlagIntReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSRTFlagInt not implemented")
}
func (UnimplementedFFStreamServer) WaitChan(*WaitRequest, FFStream_WaitChanServer) error {
	return status.Errorf(codes.Unimplemented, "method WaitChan not implemented")
}
func (UnimplementedFFStreamServer) End(context.Context, *EndRequest) (*EndReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method End not implemented")
}
func (UnimplementedFFStreamServer) mustEmbedUnimplementedFFStreamServer() {}

// UnsafeFFStreamServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FFStreamServer will
// result in compilation errors.
type UnsafeFFStreamServer interface {
	mustEmbedUnimplementedFFStreamServer()
}

func RegisterFFStreamServer(s *grpc.Server, srv FFStreamServer) {
	s.RegisterService(&_FFStream_serviceDesc, srv)
}

func _FFStream_SetLoggingLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLoggingLevelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).SetLoggingLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/SetLoggingLevel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).SetLoggingLevel(ctx, req.(*SetLoggingLevelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_AddInput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddInputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).AddInput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/AddInput",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).AddInput(ctx, req.(*AddInputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_AddOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddOutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).AddOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/AddOutput",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).AddOutput(ctx, req.(*AddOutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_RemoveOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveOutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).RemoveOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/RemoveOutput",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).RemoveOutput(ctx, req.(*RemoveOutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_GetRecoderConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRecoderConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).GetRecoderConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/GetRecoderConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).GetRecoderConfig(ctx, req.(*GetRecoderConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_SetRecoderConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRecoderConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).SetRecoderConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/SetRecoderConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).SetRecoderConfig(ctx, req.(*SetRecoderConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_GetTolerableOutputQueueSizeBytes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTolerableOutputQueueSizeBytesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).GetTolerableOutputQueueSizeBytes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/GetTolerableOutputQueueSizeBytes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).GetTolerableOutputQueueSizeBytes(ctx, req.(*GetTolerableOutputQueueSizeBytesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_SetTolerableOutputQueueSizeBytes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTolerableOutputQueueSizeBytesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).SetTolerableOutputQueueSizeBytes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/SetTolerableOutputQueueSizeBytes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).SetTolerableOutputQueueSizeBytes(ctx, req.(*SetTolerableOutputQueueSizeBytesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).Start(ctx, req.(*StartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_GetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).GetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/GetStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).GetStats(ctx, req.(*GetStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_GetOutputSRTStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOutputSRTStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).GetOutputSRTStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/GetOutputSRTStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).GetOutputSRTStats(ctx, req.(*GetOutputSRTStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_GetSRTFlagInt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSRTFlagIntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).GetSRTFlagInt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/GetSRTFlagInt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).GetSRTFlagInt(ctx, req.(*GetSRTFlagIntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_SetSRTFlagInt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSRTFlagIntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).SetSRTFlagInt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/SetSRTFlagInt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).SetSRTFlagInt(ctx, req.(*SetSRTFlagIntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FFStream_WaitChan_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WaitRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FFStreamServer).WaitChan(m, &fFStreamWaitChanServer{stream})
}

type FFStream_WaitChanServer interface {
	Send(*WaitReply) error
	grpc.ServerStream
}

type fFStreamWaitChanServer struct {
	grpc.ServerStream
}

func (x *fFStreamWaitChanServer) Send(m *WaitReply) error {
	return x.ServerStream.SendMsg(m)
}

func _FFStream_End_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FFStreamServer).End(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ffstream_grpc.FFStream/End",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FFStreamServer).End(ctx, req.(*EndRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _FFStream_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ffstream_grpc.FFStream",
	HandlerType: (*FFStreamServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetLoggingLevel",
			Handler:    _FFStream_SetLoggingLevel_Handler,
		},
		{
			MethodName: "AddInput",
			Handler:    _FFStream_AddInput_Handler,
		},
		{
			MethodName: "AddOutput",
			Handler:    _FFStream_AddOutput_Handler,
		},
		{
			MethodName: "RemoveOutput",
			Handler:    _FFStream_RemoveOutput_Handler,
		},
		{
			MethodName: "GetRecoderConfig",
			Handler:    _FFStream_GetRecoderConfig_Handler,
		},
		{
			MethodName: "SetRecoderConfig",
			Handler:    _FFStream_SetRecoderConfig_Handler,
		},
		{
			MethodName: "GetTolerableOutputQueueSizeBytes",
			Handler:    _FFStream_GetTolerableOutputQueueSizeBytes_Handler,
		},
		{
			MethodName: "SetTolerableOutputQueueSizeBytes",
			Handler:    _FFStream_SetTolerableOutputQueueSizeBytes_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _FFStream_Start_Handler,
		},
		{
			MethodName: "GetStats",
			Handler:    _FFStream_GetStats_Handler,
		},
		{
			MethodName: "GetOutputSRTStats",
			Handler:    _FFStream_GetOutputSRTStats_Handler,
		},
		{
			MethodName: "GetSRTFlagInt",
			Handler:    _FFStream_GetSRTFlagInt_Handler,
		},
		{
			MethodName: "SetSRTFlagInt",
			Handler:    _FFStream_SetSRTFlagInt_Handler,
		},
		{
			MethodName: "End",
			Handler:    _FFStream_End_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WaitChan",
			Handler:       _FFStream_WaitChan_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ffstream.proto",
}
